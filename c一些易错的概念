//extern "C" 的作用是为了能够正确的实现 C++ 代码调用 C 语言代码。加上 extern "C" 后，会指示编译器这部分代码按照 C 语言（而不是 C++）的方式进行编译。
由于 C++ 支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；
而C语言并不支持函数重载，因此编译 C 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 这个功能十分有用处，因为在 C++ 出现以前，
很多代码都是 C 语言写的，而且很底层的库也是 C 语言写的，为了更好的支持原来的 C 代码和已经写好的 C 语言库，需要在 C++ 中尽可能的支持 C，而 extern "C" 就是其中的一个策略。//


//两个线程并发执行以下代码,假设a是全局变量,那么以下输出___哪个是可能的?
int a=1;
void foo(){
    ++a;
    printf("%d", a);
}
答案是;ABCD 假设线程x和y同时执行，x和y可随时被抢占，a的初始值为1 A：3, 2 y先执行++a，a为2; y再执行printf，a入栈，在打印到终端之前切换到x x执行＋＋a，a为3; 
x执行printf，输出3;再切换到y y执行打印，输出2 B：2 3 x先执行＋＋a，a为2; x再执行printf，输出2;切换到y y执行＋＋a，a为3; y执行printf，输出3; 
C：3 3 x先执行＋＋a，a为2;切换到y y执行＋＋a，a为3; y执行printf，输出3;切换到x x执行printf，输出3 D：2 2 类似C， 执行++a操作但没有写回到内存 这里关键有两点： 
（1)两个线程可随时被抢占 （2)＋＋a和printf不是原子指令，可随时被打断；特别注意函数printf，a作为参数压栈后，a再变化则不会影响输出（printf实际打印的是压栈的参数，是值拷贝的栈变量）//




//%m.ne
输出数据共占m列，n位小数，数值长度如果小于m则左边补空格

%m.ns
输出m列，只取字符串左端n个字符，若这n个字符输出在m列右侧，左补空格。
可见：
我们的m是限定输出的长度，但是如果n是大于m的并且字符串长度是大于n的，将会输入n个字符。

如果字符串长度是小于这个m的，并且n也是小于m的，输出长度就是m，读取数据的内容是从字符串左边到右边取n个，不足m的左边补空格。

实际上来说，n是实际读取字符串时的长度，但是m是输出长度，当读取长度大于n大于输出长度m时，会输出m的长度，字符串长度不足m n中最小时左边补空格。

这时候出现了6位，但是左边是补了空格的。
所以我们这个格式是限定这个字符串长度在m 到 n之间，如果不足则左边
补空格。
同理： %m.n e也是如此//


//下面程序的运行结果是（）
int main()
{
    char ch[7] = {"65ab21"};
    int i, s=0;
    for(i = 0; ch[i] >= '0' && ch[i] <= '9'; i += 2)
        s = 10*s + ch[i] - '0';
    printf("%d\n", s);
    return 0;
}
进入for循环时，i的值为0，表达式(ch[i]>=’0’ && ch[i]<=’9’)是用来检测ch[i]是否为数字字符，
因为ch[0]是’6’，所以表达式为真，进入循环体中执行s=10*s+ch[i]-‘0’;语句，该语句的功能就是将数字串转换成相应的整数，
因s的初值为0，所以s的结果为6。语句执行完后，再将i增2，再判断ch[2]是否为数字字符，因ch[2]是’a’，表达式为假，循环退出。所以s的值输出为6，故正确答案是C.//


//执行下面代码后
int num = 7, sum = 7;
sum = num++, sum++, ++num;
后sum的值为（ ）
（sum = num++）, sum++, ++num; 优先级注意一下//




//下面是不可重载的运算符列表：
.：成员访问运算符
.*, ->*：成员指针访问运算符
::：域运算符
sizeof：长度运算符
?:：条件运算符
#： 预处理符号//



//B 地址变量比较可知数据存储哪个位于高位，大端存储和小端存储模式可通过地址比较得到
C 相减得到偏移地址
D 指针指向数组时，指针与数组指向同一地址
两个指针相加，没有意义//




//
下面程序段的输出结果为（ ）
int a, b;
b = (a = 3*5, a*4, a*5);
printf("%d",b);
逗号表达式，里面每个表达式也会运算，从左到右。最后结果是最后那个表达式。(注意逗号表达式需要有括号)  
赋值运算符的优先级是14，而逗号运算符的优先级是15.也就是说上面的表达式为b = (a = 15， 60,  75)。所以a的值为15，b的值为75。//

//链接：https://www.nowcoder.com/questionTerminal/d0129492c2b741b8b64b3adb92c5dafd
来源：牛客网

可以把它作为一般的函数一样调用，但是由于内联函数在需要的时候，会像宏一样展开，所以执行速度确比一般函数的执行速度要快。
当然，内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。
(换句话说就是，你使用内联函数，只不过是向编译器提出一个申请，编译器可以拒绝你的申请）这样，内联函数就和普通函数执行效率一样了。

当只有一个地方调用了内联函数时，编译器会在调用处将内联函数展开，这样就少了函数的跳转指令，栈的扩展指令，因此可能减小文件的大小//


//C语言源程序的基本结构单位是main函数，请问这句话的说法是正确的吗？
C程序的基本组成单位是 函数//




//用printf函数输出一个字符串时，格式字符为%s，输出项可以是此字符串或存放此字符串的数组的数组名。请问这句话的说法是正确的吗？
正确
错误
选A：正确，输出项只要不是个变量就可以正常地进行输出，数组名不是变量，数组中的 i [n]才算变量//


//
malloc的函数原型：void* malloc (size_t size);申请1*size大小的空间 
calloc的函数原型：void* calloc (size_t num, size_t size);申请num * size大小的空间 即1块 和 n块//



//#include <stdio.h>
    main(){
    int a = 2, c = 5;
    printf("a=%%d,b=%%d\n", a, c);
}
则程序的输出结果是（）a=%d,b=%d//


//main函数可以调用自己，函数调用本身叫做函数的递归。和普通的函数递归调用一样，只要设置 结束条件即可。关于main函数的递归调用实例//

//scanf 和 printf 是 C 语言提供的输入输出函数 , 所以 B 错误。由 printf 输出的数据都隐含右对齐 , 所以 A 错误。
Printf 输出数据所占的宽度由系统决定 , 所以 D 错误。//

//链接：https://www.nowcoder.com/questionTerminal/35de66cf75ed42fca57d3818e7c0fbc5
来源：牛客网

从文件编码的方式来看，文件可分为ASCII码文件（文本文件）和二进制文件两种。ASCII码文件可在屏幕上按字符显示的，
例如源程序文件就是ASCII码文件，由于按字符显示，可以识别；二进制文件是按二进制的编码方式来存放文件的，二进制文件虽然也可以在屏幕上显示，显示为乱码。//


//在32位平台上
struct {
    unsigned char a;
    int b;
    short c
} s;
请问s的起始地址下面说法正确的是（）
单字节对齐
双子节对齐
四字节对齐
说法都不对
结构体内int 占用内存最大，为4字节，故采用四字节对齐，//

//A 选项正确，int a[10]={0, 0, 0, 0, 0}; 前 5 个元素为 0，后面 5 个元素编译器补为 0
B 选项正确，int a[10]={  }; 编译器自动将所有元素置零
C 选项正确，int a[] = {0}; 编译器自动计算元素个数
D 选项错误，a 是整型数组，10*a 操作非法//


//rewind函数的作用就是将文件位置指针重新指向文件的开始位置//

//程序行、语句、函数都是由字符构成的，字符是C语言的最小单位//



//已知int i=1, j=2;，则表达式i+++j的值为（ ）
A 1
B 2
C 3
D 4
优先级：后置++  高于  前置++  高于  +   因此先运算i++,i++为1（注意后++的话，i++还是1，而
i是2）然后再加上j=2,所以为3//

//以下程序的输出是（）
union myun {
    struct { int x, y, z;} u;
    int k;
} a;
int main()
{
    a.u.x = 4;
    a.u.y = 5;
    a.u.z = 6;
    a.k = 0;
    printf("%d\n", a.u.x);
}
是一联合体变量，其包含两个成员：一个是结构体类型成员u，一个
是整型变量k，联合体变量a所占内存大小由结构体成员u来决定，k与结构体成员u的成
员x共用同一内存单元，所以执行a.k=0相当于执行a.u.x=0，故正确答案是D
应该是，联合体内存大小就是结构体内存大小，那么其他的成员变量的存储的地址就会和结构体重叠，都是int类型按顺序的话，先和X重叠//


//在64位操作系统上，下面程序返回结果是（）
int main() {
    int *k[10][30];
    printf("%d\n", sizeof(k));
    return 0;
}
8*30*10=2400//




//struct s
{
    int x: 3;
    int y: 4;
    int z: 5;
    double a;
}
求sizeof(s). 该结构体中是位操作，三个变量共占用一个int类型的大小，int类型占用4个字节，
double占用8个字节。为了实现内存对其，int类型需要填充4个字节的长度。 选A//



//函数调用语句
func(rec1, rec2 + rec3, (rec4, rec5));
中的实在参数的个数是（   ）。
函数调用的形式： 函数名(实参1，实参2，实参3 ，... ，实参n) 实参可以是具有确定值的常量、变量、表达式、函数等 本题中： 
实参1=rec1 实参2=rec2+rec3 实参3=(rec4,rec5) 故实参个数为3.

//float 类型（即 IEEE754 单精度浮点数格式）能表示的最大整数是（ ）。 
float指数位8位，指数范围-128至127 。小数位23位。。则最大数为1.11111111111111111111111*2^127=(2-2^-23)*2^127=2^128-2^104//



//void main(void) {
    char *s = "1314520";
    int v1 = 0, v2 = 0, v3 = 0, v4 =0;
    for (int i = 0; s[i]; i++) {
        switch(s[i]) {
            default: v4++;
            case '1': v1++;
            case '2': v2++;
            cas3 '3': v3++;
        }
    }
    printf("%d, %d, %d, %d", v4,v1,v2,v3)
}
链接：https://www.nowcoder.com/questionTerminal/99bd0d349c7e42a7b90d2c53ffaec35a
来源：牛客网

default顾名思义是缺省情况，只有任何条件都不匹配的情况下才会执行，故会匹配到s[i]为‘4’，‘5’，‘0’ 的情况。于是v4++三次，v4=3.并且这个default后没有使用break语句，
于是case‘1’、‘2’、‘3’都会执行三次。注意到所以语句都没有加break，
则语句执行过之后会继续下面的case语句，另外由于s[i]中有两个1，故v1,v2,v3此时为5.另外有一个2，v2,v3++后为6，还有一个case3 于是v3++.最终v3为7.//


//函数定义时每个形参都必须指明数据类型符，形参之间必须以逗号隔开，所
以B和D是错误的，另外，函数定义时末尾不能带分号，只有函数说明时才带分号，所以
C也是错误的。故正确答案是A。//

//因为printf
中输出格式控制符是%3.0f，即不输出小数位，//



//.
下面程序段的运行结果是（）（注：□代表空格）
char a[7]="abcde";
char b[4]="ABC";
strcpy (a,b);
printf("%c",a[4]);//


//运行以下C语言代码，输出的结果是（）
#include <stdio.h>
int main()
{
    char *str[3] ={"stra", "strb", "strc"};
    char *p =str[0];
    int i = 0;
    while(i < 3)
    {
        printf("%s ",p++);
        i++;
    }
    return 0;
}
答案 stra tra ra
创建了一个指针数组str，它的每个数组元素相当于一个指针变量，也就是说str数组中每个元素存放的是字符串的地址。
str[0]存放的视第一个字符串的地址，赋值给p，p是一个指向char型元素的指针，printf输出遇到空字符停止 %s也比较重要//

//return 后面括号的值不一定是函数的值，譬如函数返回值与return 类型不一致需要类型转换，
返回值为 int ，retun 3.2 ，那么肯定会进行转换的//

//
/+数字 表示8进制
//



//#include <stdio.h>
main() {
    int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, *p = a + 5, *q = NULL;
    *q = *(p+5);
    printf("%d %d\n", *p, *q);
}
运行会报错 //

//
数组声明时只能用常量，比如int arr[5]；不可以使用变量，比如int a=5;int arr[a];，这样是错误的，虽然DEV C++编译可以通过，但不代表它是正确的。
const int a=5;int arr[a];这样的话就正确。
这道题呢，问的是引用数组元素，所以，只要是整型，无论是常量还是变量，还是表达式，都是正确的。//

//对于下面语句说法正确的是（）
struct Property{
    char name[20];
    char value[40];
} p1={"name","Zhangsan"}, p2={"age"}, p3={,"b1ue"}, p4=p1;
A p1出错
B p2出错
C p3出错
D p4出错
正确答案：C
参考答案： 选C。考察的是结构体以及结构体变量的初始化。（题干p1处后半括号应该改为“ } ”） 结构是 C 编程中另一种用户自定义的可用的数据类型，允许存储不同类型的数据项。 
选项A：传统的依次初始化每一个成员，所以A正确。 
选项B：默认初始化第一个成员name，所以B正确。 选项C：语法错误 选项D：等同于选项A，属于相同结构体下的变量之间的赋值。所以D正确。//


//有函数定义：
void test(int a){} 
void test(float a){} 
则以下调用错误的是：
A test(1);
B test(‘c’);
C test(2+’d’)；
D test(0.5)；
如果只有一个test函数，不管参数是int 还是float类型，test(0.5)都不会报错，只有两个同时存在时才会报错，说明double既可以转化为int 也可以i转为float类型。
题目中之所以报错是因为有多个重载函数都可以调用。

//单目运算符、三目运算符和赋值运算符的结合性是从右到左。条件运算符？：就是三目运算符。//


//在C语言中，能代表逻辑值“真”的是（ D）
A True
B 大于0的数
C 非0整数
D 非0的数
c语言中没有布尔类型， 0代表真，非0的其他值代表假//

//printf中，格式说明符的个数和输出项的个数不等时怎么办？分多于和少于两种情况详细说明一下……
1、格式说明符的个数多于输出项的个数：
相对应的按正常输出，多出来的则是内存中的随机地址按格式说明符格式输出
比如：
printf("%c %d %x %x %x %x\n",'c',2);
调试输出结果为
c 2 401232 77be2088 ffffffff 77bfc3ce
2、格式说明符的个数少于输出项的个数：
这种情况就输出格式说明符的个数
比如：
int x=2;
printf("%d %d \n",x=x+2,x+1,x);
结果输出为：4 3
而
int x=2;
printf("%d %d \n",x=x+2,x=x+1,x);
则输出： 5 3//



//算法一般用类C语言之类的伪码来描述，如果用C语言等高级语言来描述，则算法实际上就是程序了。
对
错。正确答案是错
程序=数据结构+算法//
