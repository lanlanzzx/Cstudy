//extern "C" 的作用是为了能够正确的实现 C++ 代码调用 C 语言代码。加上 extern "C" 后，会指示编译器这部分代码按照 C 语言（而不是 C++）的方式进行编译。
由于 C++ 支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；
而C语言并不支持函数重载，因此编译 C 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 这个功能十分有用处，因为在 C++ 出现以前，
很多代码都是 C 语言写的，而且很底层的库也是 C 语言写的，为了更好的支持原来的 C 代码和已经写好的 C 语言库，需要在 C++ 中尽可能的支持 C，而 extern "C" 就是其中的一个策略。//


//两个线程并发执行以下代码,假设a是全局变量,那么以下输出___哪个是可能的?
1
2
3
4
5
int a=1;
void foo(){
    ++a;
    printf("%d", a);
}
答案是;ABCD 假设线程x和y同时执行，x和y可随时被抢占，a的初始值为1 A：3, 2 y先执行++a，a为2; y再执行printf，a入栈，在打印到终端之前切换到x x执行＋＋a，a为3; 
x执行printf，输出3;再切换到y y执行打印，输出2 B：2 3 x先执行＋＋a，a为2; x再执行printf，输出2;切换到y y执行＋＋a，a为3; y执行printf，输出3; 
C：3 3 x先执行＋＋a，a为2;切换到y y执行＋＋a，a为3; y执行printf，输出3;切换到x x执行printf，输出3 D：2 2 类似C， 执行++a操作但没有写回到内存 这里关键有两点： 
（1)两个线程可随时被抢占 （2)＋＋a和printf不是原子指令，可随时被打断；特别注意函数printf，a作为参数压栈后，a再变化则不会影响输出（printf实际打印的是压栈的参数，是值拷贝的栈变量）//




//%m.ne
输出数据共占m列，n位小数，数值长度如果小于m则左边补空格

%m.ns
输出m列，只取字符串左端n个字符，若这n个字符输出在m列右侧，左补空格。
可见：
我们的m是限定输出的长度，但是如果n是大于m的并且字符串长度是大于n的，将会输入n个字符。

如果字符串长度是小于这个m的，并且n也是小于m的，输出长度就是m，读取数据的内容是从字符串左边到右边取n个，不足m的左边补空格。

实际上来说，n是实际读取字符串时的长度，但是m是输出长度，当读取长度大于n大于输出长度m时，会输出m的长度，字符串长度不足m n中最小时左边补空格。

这时候出现了6位，但是左边是补了空格的。
所以我们这个格式是限定这个字符串长度在m 到 n之间，如果不足则左边
补空格。
同理： %m.n e也是如此//


//下面程序的运行结果是（）
int main()
{
    char ch[7] = {"65ab21"};
    int i, s=0;
    for(i = 0; ch[i] >= '0' && ch[i] <= '9'; i += 2)
        s = 10*s + ch[i] - '0';
    printf("%d\n", s);
    return 0;
}
进入for循环时，i的值为0，表达式(ch[i]>=’0’ && ch[i]<=’9’)是用来检测ch[i]是否为数字字符，
因为ch[0]是’6’，所以表达式为真，进入循环体中执行s=10*s+ch[i]-‘0’;语句，该语句的功能就是将数字串转换成相应的整数，
因s的初值为0，所以s的结果为6。语句执行完后，再将i增2，再判断ch[2]是否为数字字符，因ch[2]是’a’，表达式为假，循环退出。所以s的值输出为6，故正确答案是C.//


//执行下面代码后
int num = 7, sum = 7;
sum = num++, sum++, ++num;
后sum的值为（ ）
（sum = num++）, sum++, ++num; 优先级注意一下//




//下面是不可重载的运算符列表：
.：成员访问运算符
.*, ->*：成员指针访问运算符
::：域运算符
sizeof：长度运算符
?:：条件运算符
#： 预处理符号//



//B 地址变量比较可知数据存储哪个位于高位，大端存储和小端存储模式可通过地址比较得到
C 相减得到偏移地址
D 指针指向数组时，指针与数组指向同一地址
两个指针相加，没有意义//
